package modelgen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
	"unicode"

	"github.com/matt0792/modelgen/internal/generator"
	"github.com/matt0792/modelgen/internal/reader"
	"github.com/matt0792/modelgen/internal/types"
	"github.com/matt0792/modelgen/internal/util"
)

type ModelGen struct {
	reader        *reader.Reader
	generator     *generator.Generator
	configs       []types.MappingConfig
	targetPackage string
}

func New(targetPackage string) *ModelGen {
	return &ModelGen{
		reader:        reader.NewReader(""),
		generator:     generator.New(),
		targetPackage: targetPackage,
	}
}

// Register returns a fluent builder
//
// Source represents the external model to generate local mappings to/from
func (m *ModelGen) Register(source interface{}) *MappingBuilder {
	return &MappingBuilder{
		parent:     m,
		source:     source,
		targetName: "", // derive from source if not set
		config: types.MappingConfig{
			OmitFields: make(map[string]bool),
			FieldMap:   make(map[string]string),
		},
	}
}

// Map registers and builds mappings for all fields in the source model, panics on err
//
// For more control/custom mappings, use Register()
func (m *ModelGen) Map(source interface{}) {
	if err := m.Register(source).Build(); err != nil {
		panic(err)
	}
}

type MappingBuilder struct {
	parent     *ModelGen
	source     interface{}
	targetName string // (optional) override for struct name
	config     types.MappingConfig
}

// Omit skips mapping for the specified field
func (b *MappingBuilder) Omit(fields ...string) *MappingBuilder {
	for _, field := range fields {
		b.config.OmitFields[field] = true
	}
	return b
}

// MapField configures a custom mapping
func (b *MappingBuilder) MapField(sourceField, targetField string) *MappingBuilder {
	b.config.FieldMap[sourceField] = targetField
	return b
}

// WithTargetName allows a custom target struct name
//
// Derives name from source if not set
func (b *MappingBuilder) WithTargetName(name string) *MappingBuilder {
	b.targetName = name
	return b
}

// Build builds struct with mapping methods
func (b *MappingBuilder) Build() error {
	// read info from source struct
	sourceInfo, err := b.parent.reader.Read(b.source)
	if err != nil {
		return err
	}

	// derive target name if not set
	targetTypeName := b.targetName
	if targetTypeName == "" {
		targetTypeName = sourceInfo.TypeName
	}

	// generate target struct info from source
	targetInfo := b.deriveTargetInfo(sourceInfo, targetTypeName)

	b.config.SourceType = sourceInfo
	b.config.TargetType = targetInfo

	b.parent.configs = append(b.parent.configs, b.config)
	return nil
}

// deriveTargetInfo creates a target StructInfo from the source, applying omit and field mappings
func (b *MappingBuilder) deriveTargetInfo(sourceInfo *types.StructInfo, targetTypeName string) *types.StructInfo {
	targetInfo := &types.StructInfo{
		PackageName: b.parent.targetPackage,
		TypeName:    targetTypeName,
		Fields:      []types.FieldInfo{},
	}

	// build target fields from source
	for _, sourceField := range sourceInfo.Fields {
		if b.config.OmitFields[sourceField.Name] {
			continue
		}

		// get target field name & check for custom mapping
		targetFieldName := sourceField.Name
		if mappedName, ok := b.config.FieldMap[sourceField.Name]; ok {
			targetFieldName = mappedName
		}

		// remove source package prefix for nested
		cleanedType := b.cleanTypeName(sourceField.Type, sourceInfo.PackageName)

		targetField := types.FieldInfo{
			Name:      targetFieldName,
			Type:      cleanedType,
			IsPointer: sourceField.IsPointer,
			IsSlice:   sourceField.IsSlice,
			IsNested:  sourceField.IsNested,
		}

		targetInfo.Fields = append(targetInfo.Fields, targetField)
	}

	return targetInfo
}

func (m *ModelGen) Generate(outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	for _, config := range m.configs {
		if err := m.generateFile(outputDir, config); err != nil {
			return err
		}
	}

	return nil
}

func (m *ModelGen) generateFile(outputDir string, config types.MappingConfig) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by modelgen. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// version: %s\n", util.GetVersion())
	fmt.Fprintf(&buf, "// generated at: %s\n", time.Now().UTC().Format(time.RFC3339))
	buf.WriteString("\n")

	// write package declaration
	fmt.Fprintf(&buf, "package %s\n\n", config.TargetType.PackageName)

	// collect imports for this struct
	imports := m.collectImportsForConfig(config)
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			fmt.Fprintf(&buf, "\t\"%s\"\n", imp)
		}
		buf.WriteString(")\n\n")
	}

	// generate struct and methods
	code, err := m.generator.GenerateStructAndMethods(config)
	if err != nil {
		return err
	}
	buf.WriteString(code)

	// format
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format error for %s: %w\nGenerated code:\n%s",
			config.TargetType.TypeName, err, buf.String())
	}

	// create filename
	filename := toSnakeCase(config.TargetType.TypeName) + ".go"
	filepath := filepath.Join(outputDir, filename)

	// write file
	if err := os.WriteFile(filepath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", filename, err)
	}

	return nil
}

// --- Helpers ---

func (m *ModelGen) collectImportsForConfig(config types.MappingConfig) []string {
	importSet := make(map[string]bool)

	// Add source package import
	if config.SourceType.PackagePath != "" &&
		config.SourceType.PackagePath != config.TargetType.PackagePath {
		importSet[config.SourceType.PackagePath] = true
	}

	// Scan fields for additional imports
	for _, field := range config.SourceType.Fields {
		if imp := m.extractImportFromType(field.Type); imp != "" {
			importSet[imp] = true
		}
	}

	// Convert to sorted slice for deterministic output
	imports := make([]string, 0, len(importSet))
	for imp := range importSet {
		imports = append(imports, imp)
	}
	sort.Strings(imports)

	return imports
}

func (m *ModelGen) collectAllImports() []string {
	importsMap := make(map[string]bool)

	for _, config := range m.configs {
		// add source package import
		if config.SourceType.PackagePath != "" {
			importsMap[config.SourceType.PackagePath] = true
		}

		// check for time.Time
		// TODO probably need to do this for other types
		for _, field := range config.SourceType.Fields {
			if strings.Contains(field.Type, "time.Time") {
				importsMap["time"] = true
			}
		}
		for _, field := range config.TargetType.Fields {
			if strings.Contains(field.Type, "time.Time") {
				importsMap["time"] = true
			}
		}
	}

	imports := make([]string, 0, len(importsMap))
	for imp := range importsMap {
		imports = append(imports, imp)
	}
	return imports
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}

func (m *ModelGen) extractImportFromType(typeName string) string {
	clean := strings.TrimLeft(typeName, "*[]")

	// Extract package path (e.g., "github.com/user/pkg.Type" -> "github.com/user/pkg")
	if idx := strings.LastIndex(clean, "."); idx != -1 {
		pkgPath := clean[:idx]
		if strings.Contains(pkgPath, "/") || strings.Contains(pkgPath, ".") {
			return pkgPath
		}
	}

	return ""
}

func (b *MappingBuilder) cleanTypeName(typeName string, sourcePackage string) string {
	// "externalservice.Post" -> "Post"
	sourcePrefix := sourcePackage + "."
	return strings.ReplaceAll(typeName, sourcePrefix, "")
}
